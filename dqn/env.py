#!/usr/bin/python3
import datetime
import collections
import sys; sys.path.append("..")
import melee
import argparse
import signal
import numpy as np

#This example program demonstrates how to use the Melee API to run dolphin programatically,
#   setup controllers, and send button presses over to dolphin

class Env(object):

    def __init__(self, DQN, max_episodes, stage="FINAL_DESTINATION",
                 opponent="HUMAN", port=2, opponent_port=1):

        self.DQN           = DQN
        self.max_games     = max_games
        self.stage         = stage
        self.opponent      = opponent
        self.port          = port
        self.opponent_port = opponent_port
        self.dolphin       = None
        self.gamestate     = None
        self.controller    = None
        self.last_action   = None

    def signal_handler(self, signal, frame):
	self.dolphin.terminate()
	print("Shutting down cleanly...")
	sys.exit(0)

    # Just records from the global time. Is only interesing as a reference
    def get_time(self):
	return str(datetime.datetime.now())[11:].split(".")[0]

    #TODO 
    def get_elapsed_time(self):
        pass

    def navigate_menu(self):
        melee.menuhelper.choosestage(stage=melee.enums.Stage.FINAL_DESTINATION,
	    self.gamestate, self.controller)

    def navigate_postgame(self):
	melee.menuhelper.skippostgame(self.controller)

    """ Requests an action from the Q network object that was passed in, 
    you can see that the network only can move at the pace of the game, e.g. 60 fps
    once we have an action, we do a lookup and return the function. We counter this 
    with some probability of selecting the last action taken [(noise?) --probably remove]
    """
    def get_network_action(self):

        action = int(DQN.action_signal())
        prob_repeat = np.random.normal(.5, .1, 1)
        if .1 > prob_repeat or .9 < prob_repeat:
            action = self.last_action
        action_func = manager['actions'][action]
        self.last_action = action_func
        return action_func

    def run(self):
        """ Were just going to set up all of our class variables here
        this involves the initialization of dolphin, the controller, 
        and the gamestate objects. This effectively pulls the center
        of operation from the melee module into a more local scope."""

        log = None # For now 
	if self.opponent is "HUMAN":
            opponent_type = melee.enums.ControllerType.STANDARD
        else if self.opponent is "BOT":
            opponent_type = melee.enums.COntrollerType.STANDARD
        else
            pass

	print("Starting Training Session")
	self.dolphin = melee.dolphin.Dolphin(self.port, self.opponent_port, opponent_type, log)
        self.gamestate = melee.gamestate.GameState(self.dolphin)
	self.controller = melee.controller.Controller(port=self.port, dolphin=self.dolphin)
	signal.signal(signal.SIGINT, self.signal_handler)
	self.dolphin.run(render=True)
	self.controller.connect()
	print("STARTING: {}".format(self.get_time()))
	#Main loop
	current_state = "START"
	r = len(melee.techskill.manager['actions'])
        
        """ Here the training program is going to repeat over an amount of games, signals are 
        going to be passed between the loop here and the neural network that we defined in 
        model.py. Here we will feed dolphin the actual data that is generated by the neural
        network. Gamestate will be advanced, and at every frame we will request an action, 
        given state vars that we pass to the model. 
        LOOP:
        1: start next frame 
        2: pass vars and do a forward pass to get action 
        3: receive and perform action / backwards pass """

        for _ in range(self.max_games):
	    #"step" to the next frame
	    self.gamestate.step()
	    if self.gamestate.menu_state == melee.enums.Menu.IN_GAME:
                action = melee.techskill.manager['actions'][np.random.randint(0, r)]
                print ("{} GAMESTATE: IN_GAME, ACTION: {}".format(get_time(), action.__name__))
                action(ai_state=gamestate.ai_state, controller=controller)
	    #If we're at the character select screen, choose our character
	    elif gamestate.menu_state == melee.enums.Menu.CHARACTER_SELECT:
		if current_state is not "CHARACTER_SELECT":
		    print("{} GAMESTATE: CHARACTER SELECT".format(get_time()))
		    current_state = "CHARACTER_SELECT"

		melee.menuhelper.choosecharacter(melee.enums.Character.FOX,
		    self.gamestate, self.controller, swag=True,
		    start=False)
	    #If we're at the postgame scores screen, spam START
	    elif gamestate.menu_state == melee.enums.Menu.POSTGAME_SCORES:
                self.navigate_postgame()
	    #If we're at the stage select screen, choose a stage
	    elif gamestate.menu_state == melee.enums.Menu.STAGE_SELECT:
		self.navigate_menu()
	    #Flush any button presses queued up
	    self.controller.flush()

    if __name__ == "__main__":
	main()
