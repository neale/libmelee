#!/usr/bin/python3
import datetime
import collections
import sys; sys.path.append("..")
import melee
import argparse
import signal
import numpy as np

#This example program demonstrates how to use the Melee API to run dolphin programatically,
#   setup controllers, and send button presses over to dolphin

class Env(object):

    def __init__(self, DQN, max_games, stage="FINAL_DESTINATION",
                 opponent="HUMAN", port=2, opponent_port=1, DEBUG=1):

        self.DQN           = DQN
        self.max_games     = max_games
        self.stage         = stage
        self.opponent      = opponent
        self.port          = port
        self.opponent_port = opponent_port
        self.dolphin       = None
        self.gamestate     = None
        self.controller    = None
        self.last_action   = None
        self.manager       = melee.techskill.get_actions()
        self.games         = 0
        self.DEBUG         = DEBUG

    def signal_handler(self, signal, frame):
        self.dolphin.terminate()
        print("Shutting down cleanly...")
        sys.exit(0)

    # Just records from the global time. Is only interesing as a reference
    def get_time(self):
        return str(datetime.datetime.now())[11:].split(".")[0]

    #TODO 
    def get_elapsed_time(self):
        pass

    def navigate_menu(self):
        #melee.menuhelper.choosestage(melee.enums.Stage.DREAMLAND,
        #    self.gamestate, self.controller)
        pass
    def navigate_postgame(self):
        melee.menuhelper.skippostgame(self.controller)

    def navigate_character_select(self):
        melee.menuhelper.choosecharacter(melee.enums.Character.FOX,
            self.gamestate, self.controller, swag=False, start=False)

    """ Requests an action from the Q network object that was passed in, 
    you can see that the network only can move at the pace of the game, e.g. 60 fps
    once we have an action, we do a lookup and return the function. We counter this 
    with some probability of selecting the last action taken [(noise?) --probably remove]
    """
    def get_network_action(self):

        #action = int(DQN.action_signal())
        action = int( self.DQN.test_env() ) # gets random signal from test
        if type(action) is not int:
            print ("something went wrong with action choice, defaulting to 0")
            print ("action details: {}".format(action))
            action = 0; action_func = None
        action_func = self.manager['actions'][action]
        self.last_action = action_func
        return action_func

    def collect_gradients(self):
        pass
    #resets the state variables after a game has concluded, or something has gone wrong
    def reset_vars(self):
        self.actions = None
        self.last_action = None
        self.games += 1
        self.log_env(1, "Game Concluded\nElasped Games: {}".format(self.games))

    def log_env(self, log_level, msg):
        if (self.DEBUG is 1) and (log_level >= 0):
            if log_level is 2: print ('!! {}'.format(msg))
            elif log_level is 1: print ('* {}'.format(msg))
            elif log_level is 0: print ('* {}'.format(msg))
        
        else:
            if log_level is 0: print(msg)

    def run(self):
        """ Were just going to set up all of our class variables here
        this involves the initialization of dolphin, the controller, 
        and the gamestate objects. This effectively pulls the center
        of operation from the melee module into a more local scope."""

        log = None # For now 
        if self.opponent is "HUMAN":
            opponent_type = melee.enums.ControllerType.STANDARD
        elif self.opponent is "BOT":
            opponent_type = melee.enums.ControllerType.STANDARD
        else:
            pass

        print("Starting Training Session")
        self.dolphin = melee.dolphin.Dolphin(self.port, self.opponent_port, opponent_type, log)
        self.gamestate = melee.gamestate.GameState(self.dolphin)
        self.controller = melee.controller.Controller(port=self.port, dolphin=self.dolphin)
        signal.signal(signal.SIGINT, self.signal_handler)
        self.dolphin.run(render=True)
        self.controller.connect()
        self.log_env(0, "STARTING: {}".format(self.get_time()))
        #Main loop
        current_state = "START"
        
        """ Here the training program is going to repeat over an amount of games, signals are 
        going to be passed between the loop here and the neural network that we defined in 
        model.py. Here we will feed dolphin the actual data that is generated by the neural
        network. Gamestate will be advanced, and at every frame we will request an action, 
        given state vars that we pass to the model. 
        LOOP:
        1: start next frame 
        2: pass vars and do a forward pass to get action 
        3: receive and perform action / backwards pass """
        finish_flag = False
        frame_skip = 1
        r = 12
        while self.games is not self.max_games:
            #"step" to the next frame
            self.gamestate.step()
            self.collect_gradients()
            if self.gamestate.menu_state == melee.enums.Menu.IN_GAME:
                if frame_skip == 2:
                    #action = self.manager['actions'][np.random.randint(0, 13)]
                    action = self.get_network_action()
                    print (action.__name__)
                    action(ai_state=self.gamestate.ai_state, controller=self.controller)
                    frame_skip = 1
                    #self.controller.simple_press(.5, 1, melee.enums.Button.BUTTON_B)
                else: 
                    frame_skip += 1
                    # return to normal, shouldn't have to do this
                    self.controller.simple_press(.5, .5, melee.enums.Button.BUTTON_MAIN)
            #If we're at the character select screen, choose our character
            elif self.gamestate.menu_state == melee.enums.Menu.CHARACTER_SELECT:
                self.navigate_character_select()
                finish_flag = False
            #If we're at the postgame scores screen, spam START
            elif self.gamestate.menu_state == melee.enums.Menu.POSTGAME_SCORES:
                if finish_flag == False:
                    finish_flag = True
                    self.reset_vars()
                self.navigate_postgame()
            #If we're at the stage select screen, choose a stage
            
            elif self.gamestate.menu_state == melee.enums.Menu.STAGE_SELECT:
                self.navigate_menu()
            #Flush any button presses queued up
            
            self.controller.flush()

    if __name__ == "__main__":
        main()
